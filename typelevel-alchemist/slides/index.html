<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Typelevel Alchemist</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/moon.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/solarized-dark.css">

    <style>
        code.smaller {
            font-size: 0.6em;
            line-height: 1.2em;
        }
    </style>
    <!-- Printing and PDF exports -->
    <script>
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <!--main-->
        <section>
            <section>
                <h2><a>Typelevel alchemist</a></h2>
                <h3>Cats ecosystem in practice</h3>
                <small>Jakub Kozłowski - Scala Developer, Ocado Technology</small>
                <small>Scala Wave | September 7, 2018 | Gdańsk, Poland</small>
            </section>
            <section>
                <h2>Agenda</h2>
                <ol>
                    <li>Typeclasses recap</li>
                    <li>Higher-kinded types</li>
                    <li>Referential transparency</li>
                    <li>Tagless Final</li>
                    <li>Cats intro</li>
                    <li>Cats-effect</li>
                    <li>fs2, http4s, doobie</li>
                    <li>patterns for applications</li>
                </ol>
            </section>
            <section>
                <h3>About me</h3>
                <ul>
                    <li>Live in Wrocław, Poland</li>
                    <li>Doing Scala for 3 years</li>
                    <li>Worked @ <a href="https://scalac.io" target="_blank">Scalac</a> all that time</li>
                    <li>now @ <a href="https://ocadotechnology.com" target="_blank">Ocado Technology</a></li>
                    <li>I love ramen</li>
                    <li>Running and lifting when not injured</li>
                </ul>
            </section>
        </section>
        <!--Typeclasses recap-->
        <section>
            <section>
                <h2>Typeclasses recap</h2>
                <ul>
                    <li>What's a typeclass?</li>
                    <li>Examples</li>
                    <li>Coherence</li>
                    <li>Alternatives</li>
                </ul>
            </section>
            <section>
                <h3>What's a typeclass</h3>
                <p>Example: collapsing a list</p>
            </section>
            <section>
                <h3>Collapsing a list</h3>
                <pre><code class="scala" embed="typeclasses/collapsing-list.sc"></code></pre>
                <br/>
                <small class="fragment">Hard to extend - need a new implementation AND name for every type in list
                </small>
                <br/>
                <small class="fragment">Let's try to make that abstract</small>
                <br/>
                <br/>
                <small>Original idea from <a href="https://typelevel.org/cats/typeclasses" target="_blank">the Cats
                    documentation</a></small>
            </section>
            <section>
                <h3>Monoid typeclass</h3>
                <pre><code class="scala" embed="typeclasses/collapsing-monoid.sc"></code></pre>
            </section>
            <section>
                <h3>Usage of new implementation</h3>
                <pre><code class="scala" embed="typeclasses/collapsing-monoid-usage.sc"></code></pre>
            </section>
            <section>
                <h3>Typeclasses should have laws</h3>
                <pre><code class="scala" embed="typeclasses/monoid-laws.sc"></code></pre>
            </section>
            <section>
                <h3>Coherence</h3>
                <ul>
                    <li class="fragment">Each pairing of (type, typeclass implementation) must be unique</li>
                    <li class="fragment">Not enforced by Scala</li>
                </ul>
                <br/><br/>
                <p class="fragment">Takeaway: Not all traits with implicit instances are typeclasses</p>
            </section>
            <section>
                <h2>Alternatives</h2>
            </section>
            <section>
                <h3>Runtime reflection</h3>
                <ul>
                    <li>e.g. JSON serializers in Jackson or json4s</li>
                    <li>Hard to extend (registering instances in global, mutable scope)</li>
                    <li>No compile-time checks, no runtime safety</li>
                </ul>
            </section>
            <section>
                <h3>Pattern matching</h3>
                <ul>
                    <li>Non-extensible</li>
                    <li>No compile-time checks, no runtime safety</li>
                    <li>Still hard with generics (requires ClassTag, which is... a typeclass)</li>
                </ul>
            </section>
            <section>
                <h3>Comparison</h3>
                <table>
                    <tr>
                        <td></td>
                        <td>Extensible</td>
                        <td>Generics</td>
                        <td>Runtime safe</td>
                    </tr>
                    <tr>
                        <td>Reflection</td>
                        <td title="Users can usually register custom instances for their types">✅</td>
                        <td>✅</td>
                        <td title="Not checked in compile time">❌</td>
                    </tr>
                    <tr>
                        <td>Pattern matching</td>
                        <td title="Users can't add support for their types">❌</td>
                        <td title="Requires classtag (typeclass and a bit of reflection)">❌</td>
                        <td title="Exhaustivity checking">✅</td>
                    </tr>
                    <tr>
                        <td>Subtyping</td>
                        <td title="Impossible to add an instance to a type we can't or don't want to extend">❌</td>
                        <td title="Type erasure">❌</td>
                        <td title="A missing implementation is a compile-time error">✅</td>
                    </tr>
                    <tr>
                        <td>Typeclasses</td>
                        <td title="Users can provide instances for their types and foreign types">✅</td>
                        <td title="Working, even with induction (Show of `List[T : Show]`)">✅</td>
                        <td title="If it compiles, it's safe">✅</td>
                    </tr>
                </table>
            </section>
            <section>
                <h3>Polymorphism via subtyping</h3>
                <pre><code class="scala" embed="typeclasses/monoid-pair-subtyping.sc"></code></pre>
            </section>
            <section>
                <h3>Subtyping</h3>
                <ul>
                    <li>How to collapse an empty list?</li>
                    <li>Pollutes the implementing classes</li>
                    <li>All or nothing</li>
                    <li>Can't implement for types we can't control</li>
                </ul>
            </section>
            <section>
                <h3>So, typeclasses...</h3>
                <p>Standard library examples (pre-2.13)</p>
                <pre><code class="scala" embed="typeclasses/typeclasses-stdlib.scala"></code></pre>
            </section>
        </section>
        <!--HKTs-->
        <section>
            <section>
                <h2>Higher-kinded types</h2>
            </section>
            <section>
                <h3>Types</h3>
                <p class="fragment">*-kinded</p>
                <pre class="fragment"><code class="scala">String, Int, Boolean, List[Int]</code></pre>
                <p class="fragment">higher-kinded (* -> *)</p>
                <pre class="fragment"><code class="scala">Option[_], List[_], Future[_]</code></pre>
                <p class="fragment">higher-kinded types are "incomplete" - they have a hole</p>
                <p class="fragment">also called "type constructors"</p>
            </section>
            <section>
                <h3>Higher-kinded types</h3>
                <p>Type-level functions</p>
                <pre><code class="scala"></code>f      =  x  => f(x)      //function lambda</pre>
                <pre><code class="scala"></code>Option = [A] => Option[A] //type lambda</pre>
                <p class="fragment">Higher-kinded types need to be applied with a type to become a *-kinded type</p>
            </section>
            <section>
                <table>
                    <h3>Functions vs higher-kinded types</h3>
                    <tr>
                        <td>
                            <pre style="width: auto;"><code class="scala" embed="hkt/hof.sc"></code></pre>
                        </td>
                        <td>
                            <pre style="width: auto;"><code class="scala" embed="hkt/hof-2.sc"></code></pre>
                        </td>
                    </tr>
                </table>
            </section>
            <section>
                <h3>Abstracting on types</h3>
                <pre><code class="scala" embed="hkt/abstracting.sc"></code></pre>
            </section>
            <section>
                <pre><code class="scala" embed="hkt/abstracting-id.sc"></code></pre>
            </section>
            <section>
                <h3>Type lambdas</h3>
                <small>With <a href="https://github.com/non/kind-projector" target="_blank">kind-projector</a></small>
                <pre><code class="scala" embed="hkt/lambda.sc"></code></pre>
            </section>
            <section>
                <h3>Why we need type lambdas</h3>
                <pre><code class="scala" embed="hkt/why-lambdas.sc"></code></pre>
            </section>
            <section>
                <h3>Partial unification</h3>
                <small>The compiler can infer this <a href="https://github.com/typelevel/cats#getting-started"
                                                      target="_blank">(with a flag, by default in 2.13)</a>:
                </small>
                <pre><code class="scala" embed="hkt/partial-unification.sc"></code></pre>
                <small class="fragment">Unfortunately, IDEA can't (yet) :(</small>
                <img class="fragment" src="images/idea-punif-fail.png"/>
            </section>
            <section>
                <h3>Tagless Final</h3>
                <small>Fancy name for abstracting on types*</small>
                <pre><code class="scala" embed="tf/tf-example.scala"></code></pre>
                <small>* - not a precise definition, but it'll suffice</small>
            </section>
            <section>
                <h3>Why tagless?</h3>
                <ul>
                    <li>We don't couple ourselves to a specific effect like IO</li>
                    <li>We can easily swap effects for testing or if we decide to switch</li>
                    <li>Easier to work with monad transformers (explained later)</li>
                    <li>Sometimes allows for not leaking implementation details</li>
                    <li>More power to users of your library</li>
                </ul>
            </section>
        </section>
        <!--RT-->
        <section>
            <section>
                <h2>Referential transparency</h2>
                <small>If an expression <code>t</code> can be substituted by its value <code>a</code>, then it's
                    referentially transparent
                </small>
                <pre><code class="scala">//if a function f(x) is referentially transparent
//and x is referentially transparent

val a = f(x)

(a, a) <-> (f(x), f(x))</code></pre>
            </section>
            <section>
                <h3>Breaking RT - Future</h3>
                <pre><code class="scala" embed="rt/future-breaks.sc"></code></pre>
            </section>
            <section>
                <h3>Future breaks most of the time</h3>
                <pre><code class="scala" embed="rt/future-breaks-time.sc"></code></pre>
            </section>
            <section>
                <h3>Future can break even more</h3>
                <pre><code class="scala" embed="rt/future-breaks-time-2.sc"></code></pre>
            </section>
            <section>
                <h3>It hurts</h3>
                <pre><code class="scala" embed="rt/side-effects-break.sc"></code></pre>
            </section>
            <section>
                <h3>It also breaks in the other direction</h3>
                <pre><code class="scala" embed="rt/future-breaks-other-side.sc"></code></pre>
            </section>
            <section>
                <h3>Throwing breaks too</h3>
                <pre><code class="scala" embed="rt/exceptions-break.sc"></code></pre>
            </section>
            <section>
                <h3>What's a (pure) function?</h3>
                <a href="https://twitter.com/jdegoes/status/936301872066977792" target="_blank"><img
                        src="images/jdg-functions.png" style="width: 500px"/></a>
            </section>
            <section>
                <h3>Meet <code>IO</code></h3>
                <pre><code class="scala" embed="rt/io-doesnt-break.sc"></code></pre>
            </section>
            <section>
                <h3>Measure time with IO</h3>
                <pre><code class="scala" embed="rt/io-measure.sc"></code></pre>
            </section>
            <section>
                <h3>Predictable nukes with IO</h3>
                <pre><code class="scala" embed="rt/io-doesnt-break-other-side.sc"></code></pre>
            </section>
            <section>
                <h3>Why go referentially transparent?</h3>
                <ul>
                    <li>Equational reasoning</li>
                    <li>Programs as values</li>
                    <li>Testing</li>
                    <li>Local reasoning</li>
                    <li>Explicit effects, predictable code</li>
                </ul>
            </section>
            <section>
                <h3>Equational reasoning</h3>
                <small>Refactor fearlessly</small>
                <pre><code class="scala" embed="rt/equational-reasoning.sc"></code></pre>
            </section>
            <section>
                <h3>Programs as values</h3>
                <small>Pass your programs to others so that they add meaning</small>
                <pre><code class="scala" embed="rt/programs-values.sc"></code></pre>
            </section>
            <section>
                <h3>Testing</h3>
                <pre><code class="scala" embed="rt/testing.sc"></code></pre>
            </section>
            <section>
                <h3>Local reasoning</h3>
                <ul>
                    <li>Split programs more easily</li>
                    <li>Compose smaller functions into larger ones</li>
                    <li>Reason independently</li>
                </ul>
            </section>
            <section>
                <h3>Local reasoning</h3>
                <pre><code class="scala" embed="rt/local-reasoning.sc"></code></pre>
            </section>
            <section>
                <h3>A wild implicit side effect appears!</h3>
                <pre><code class="scala smaller" embed="rt/implicit-side-effect.sc"></code></pre>
                <p class="fragment">Find the side effect</p>
                <small class="fragment">(line 13, limit)</small>
            </section>
            <section>
                <h3>Explicit effects</h3>
                <pre><code class="scala" embed="rt/explicit-effects.sc"></code></pre>
            </section>
            <section>
                <h3>Checklist</h3>
                <ul>
                    <li>Is it calling the DB?</li>
                    <li>Is it calling HTTP?</li>
                    <li>Is it logging?</li>
                    <li>Is it caching?</li>
                    <li>Is it changing state?</li>
                    <li>Is it reading from a cache?</li>
                    <li>Can it throw?</li>
                    <li>Can it have a different result if you call it tomorrow?</li>
                </ul>
                <br/>
                <br/>
                <small class="fragment">If you have ≥1 checks, it's effectful - slap an IO on it</small>
            </section>
            <section>
                <h3>Predictable results</h3>
                <small>A pure function can have a limited number of implementations</small>
                <pre><code class="scala">def f[A](a: A): A</code></pre>
                <p class="fragment">has one</p>
            </section>
            <section>
                <h3>How many implementations?</h3>
                <pre><code class="scala" embed="rt/how-many.sc"></code></pre>
                <pre class="fragment"><code class="scala">def f9: IO[Unit]</code></pre>
            </section>
            <section>
                <h3>How many implementations?</h3>
                <pre><code class="scala" embed="rt/how-many-answered.sc"></code></pre>
                <pre><code class="scala">def f9: IO[Unit]</code></pre>
            </section>
            <section>
                <h3>How many implementations?</h3>
                <pre><code class="scala" embed="rt/how-many-complex.sc"></code></pre>
            </section>
            <section>
                <h3>How many implementations?</h3>
                <pre><code class="scala" embed="rt/how-many-complex-answered.sc"></code></pre>
            </section>
        </section>
        <!--cats-->
        <section>
            <section>
                <h2>Cats</h2>
            </section>
            <section>
                <h3>Cats</h3>
                <p>Core typelevel project</p>
                <ul>
                    <li>Typeclasses</li>
                    <li>Data types</li>
                    <li>Syntax</li>
                </ul>
            </section>
        </section>
        <!--cats TCs-->
        <section>
            <section>
                <h3>Typeclasses in cats</h3>
                <ul>
                    <li>Eq</li>
                    <li>Order</li>
                    <li>Monoid</li>
                    <li>Functor</li>
                    <li>Applicative</li>
                    <li>Monad</li>
                    <li>ApplicativeError</li>
                    <li>MonadError</li>
                    <li>Traverse...</li>
                </ul>
            </section>
            <section>
                <h3>Eq</h3>
                <pre><code class="scala" embed="cats/eq.scala"></code></pre>
                <p>Multiversal equality</p>
                <small>Note: typeclass definitions in the slides are simplified</small>
            </section>
            <section>
                <h3>Syntax for Cats typeclasses</h3>
                <pre><code class="scala" embed="cats/syntax.sc"></code></pre>
                <small>Tip: use consistent import style to avoid conflicts</small>
            </section>
            <section>
                <h3>Order</h3>
                <pre><code class="scala" embed="cats/order.scala"></code></pre>
                <small>Comparison, ordering</small>
            </section>
            <section>
                <h3>Show</h3>
                <pre><code class="scala" embed="cats/show.scala"></code></pre>
                <small>Text representation - type-safe <code>toString</code></small>
            </section>
            <section>
                <h3>Semigroup, Monoid</h3>
                <pre><code class="scala" embed="cats/semigroup-monoid.scala"></code></pre>
                <small>binary operation + (with monoid) identity element</small>
            </section>
            <section>
                <h3>Functor</h3>
                <pre><code class="scala" embed="cats/functor.scala"></code></pre>
                <small><code>map</code>, abstracted</small>
            </section>
            <section>
                <h3>Functor laws</h3>
                <p>There are two rules of the functor club.</p>
                <pre class="fragment"><code class="scala">//identity law
fa.map(id) == fa</code></pre>
                <pre class="fragment"><code class="scala">//composition law
fa.map(f).map(g) == fa.map(f.andThen(g))</code></pre>
            </section>
            <section>
                <h3>Applicative</h3>
                <pre><code class="scala" embed="cats/applicative.scala"></code></pre>
                <small>(potentially parallel) combination of independent effects, wrapping value in effect</small>
            </section>
            <section>
                <h3>The more real Applicative</h3>
                <pre><code class="scala" embed="cats/realer-applicative.scala"></code></pre>
            </section>
            <section>
                <h3>Monad</h3>
                <pre><code class="scala" embed="cats/monad.scala"></code></pre>
                <small>Sequential composition of effects</small>
            </section>
            <section>
                <h3>Monad laws</h3>
                <pre class="fragment"><code class="scala">//left identity
pure(a).flatMap(f) == f(a)</code></pre>
                <pre class="fragment"><code class="scala">//right identity
fa.flatMap(pure) == fa</code></pre>
                <pre class="fragment"><code class="scala">//associativity
fa.flatMap(f).flatMap(g) == fa.flatMap(a => f(a).flatMap(g))</code></pre>
            </section>
            <section>
                <h3>ApplicativeError</h3>
                <pre><code class="scala" embed="cats/aperr.scala"></code></pre>
                <small>raising errors, recovering from them</small>
            </section>
            <section>
                <h3>MonadError</h3>
                <pre><code class="scala smaller" embed="cats/monaderr.scala"></code></pre>
                <small>Running predicates, transforming errors, un-recovering</small>
            </section>
            <section>
                <h3>Traverse</h3>
                <pre><code class="scala" embed="cats/traverse.scala"></code></pre>
                <small><code>sequence</code> flips effects</small>
            </section>
            <section>
                <h3>Traverse examples</h3>
                <pre><code class="scala" embed="cats/sequence-samples.sc"></code></pre>
                <pre class="fragment"><code class="scala" embed="cats/traverse-samples.sc"></code></pre>
            </section>
            <section>
                <h3>Traverse vs sequence</h3>
                <pre><code class="scala">fa.traverse(f) == fa.map(f).sequence</code></pre>
                <pre><code class="scala">fa.sequence == fa.traverse(identity)</code></pre>
            </section>
        </section>
        <!--cats DTs-->
        <section>
            <section>
                <h2>Data types</h2>
                <ul>
                    <li>NonEmptyList</li>
                    <li>Validated</li>
                    <li>FunctionK</li>
                    <li>OptionT</li>
                    <li>EitherT</li>
                </ul>
            </section>
            <section>
                <h3>NonEmptyList (NEL)</h3>
                <pre><code class="scala" embed="cats-data/nel.scala"></code></pre>
                <p>A list that's guaranteed not to be empty</p>
                <small>With safe `head`, `tail` operations</small>
            </section>
            <section>
                <h3>Validated</h3>
                <pre><code class="scala" embed="cats-data/validated.scala"></code></pre>
                <small>like Either, but with error accumulation</small>
            </section>
            <section>
                <h3>ValidatedNel</h3>
                <pre><code class="scala">type ValidatedNel[+E, +A] = Validated[NonEmptyList[E], A]</code></pre>
                <small>Useful for error accumulation, because NEL has a semigroup</small>
                <pre><code class="scala">type EitherNel[+E, +A] = Either[NonEmptyList[E], A]</code></pre>
                <small></small>
            </section>
            <section>
                <h3>Either vs Validated: Applicative</h3>
                <pre><code class="scala" embed="cats-data/either-validated-product.sc"></code></pre>
            </section>
            <section>
                <h3>In "plain English"</h3>
                <ul>
                    <li>Applicative: if the first one fails, we fail with its error. Otherwise se check the second
                        one.
                    </li>
                    <li>Validated: if both are failed, errors are combined using the semigroup instance.</li>
                </ul>
            </section>
            <section>
                <h3>Applicative builder syntax</h3>
                <small>No need to call `product`, `map2` or `ap` directly</small>
                <pre><code class="scala smaller" embed="cats-data/applicative-builder.sc"></code></pre>
            </section>
            <section>
                <h3>FunctionK</h3>
                <pre><code class="scala" embed="cats-data/functionk.scala"></code></pre>
                <pre class="fragment"><code class="scala" embed="cats-data/functionk-example.sc"></code></pre>
            </section>
            <section>
                <h3>One more typeclass - Parallel</h3>
                <small>Not just parallelism</small>
                <pre><code class="scala" embed="cats-data/parallel.scala"></code></pre>
            </section>
            <section>
                <h3>Parallel explained</h3>
                <ul>
                    <li class="fragment">A bi-directional transformation between two isomorphic types with
                        applicatives
                    </li>
                    <li class="fragment">One has a monad, the other one can't</li>
                </ul>
                <br/><br/>
                <small class="fragment">
                    An applicative that can't be a monad does e.g. parallel execution of <code>IO</code>, or error&nbsp;accumulation
                    like <code>Validated</code>
                </small>
            </section>
            <section>
                <h3>Parallel applicative syntax</h3>
                <pre><code class="scala smaller" embed="cats-data/parallel-builder.sc"></code></pre>
                <small>Later - parallel IO</small>
            </section>
            <section>
                <h3>OptionT</h3>
                <small>Problem:</small>
                <pre><code class="scala" embed="cats-data/optiont-problem.sc"></code></pre>
                <pre class="fragment"><code class="scala" embed="cats-data/optiont-problem-naive.sc"></code></pre>
            </section>
            <section>
                <small>Solution:</small>
                <pre><code class="scala" embed="cats-data/optiont-problem.sc"></code></pre>
                <pre class="fragment"><code class="scala" embed="cats-data/optiont-problem-solution.sc"></code></pre>
            </section>
            <section>
                <h3>OptionT</h3>
                <pre><code class="scala" embed="cats-data/optiont.scala"></code></pre>
            </section>
            <section>
                <h3>EitherT</h3>
                <pre><code class="scala" embed="cats-data/eithert.scala"></code></pre>
            </section>
            <section>
                <h3>EitherT usage</h3>
                <pre><code class="scala" embed="cats-data/eithert-problem.sc"></code></pre>
                <pre><code class="scala" embed="cats-data/eithert-problem-solution.sc"></code></pre>
            </section>
        </section>
        <!--cats-effect-->
        <section>
            <section>
                <h3>Cats-effect</h3>
                <p>An IO monad for cats (and more)</p>
            </section>
            <section>
                <h3>Cats-effect</h3>
                <ul>
                    <li>More data types (IO, concurrency primitives)</li>
                    <li>More instances</li>
                </ul>
            </section>
        </section>
        <!--IO-->
        <section>
            <section>
                <h3>IO[A]</h3>
                <ul>
                    <li class="fragment">Just a data structure</li>
                    <li class="fragment">A pure, immutable value</li>
                    <li class="fragment">Preserves referential transparency</li>
                    <li class="fragment">When evaluated, can perform effects before returning a value of type A</li>
                </ul>
                <br/>
                <br/>
                <small class="fragment">Supports synchronous AND asynchronous effects</small>
            </section>
            <section>
                <h3>IO[A] is not a stream</h3>
                <p>An IO, when evaluated, will do one of these:</p>
                <ul>
                    <li>Eventually complete with a value of type A</li>
                    <li>fail with a Throwable</li>
                    <li>never complete (e.g. <code>IO.never</code>)</li>
                </ul>
            </section>
            <section>
                <h3>Creating IOs</h3>
                <pre><code class="scala" embed="io/creating-io.sc"></code></pre>
            </section>
            <section>
                <h3>IO - example</h3>
                <pre><code class="scala" embed="io/io-example.sc"></code></pre>
            </section>
            <section>
                <h3>IO - more examples</h3>
                <pre><code class="scala smaller" embed="io/io-examples-mutable.sc"></code></pre>
                <pre class="fragment"><code class="scala smaller" embed="io/io-examples-inc-random.sc"></code></pre>
            </section>
            <section>
                <h3>IO - echo name</h3>
                <small>The "hello world" of IOs</small>
                <pre><code class="scala" embed="io/io-echo.sc"></code></pre>
            </section>
            <section>
                <h3>IO - another example</h3>
                <pre class="fragment"><code class="scala smaller" embed="io/io-heisenberg.sc"></code></pre>
            </section>
            <section>
                <h3>IO gotchas</h3>
                <pre><code class="scala" embed="io/io-gotchas.sc"></code></pre>
            </section>
            <section>
                <h3>How to run?</h3>
                <pre><code class="scala" embed="io/ioapp.sc"></code></pre>
            </section>
            <section>
                <h3>How to run?</h3>
                <pre><code class="scala" embed="io/ioapp-usage.sc"></code></pre>
            </section>
        </section>
        <!--CE TCs-->
        <section>
            <section>
                <h3>Cats-effect typeclasses</h3>
                <ul>
                    <li>Bracket</li>
                    <li>Sync</li>
                    <li>LiftIO</li>
                    <li>Async</li>
                    <li>Effect</li>
                    <li>Concurrent</li>
                    <li>ConcurrentEffect</li>
                </ul>
            </section>
            <section>
                <h3>Bracket</h3>
                <small>Ensuring resource safety - loan pattern in Scala</small>
                <pre><code class="scala" embed="ce-tc/bracket.scala"></code></pre>
            </section>
            <section>
                <h3>Bracket - example</h3>
                <pre><code class="scala" embed="ce-tc/bracket-example.sc"></code></pre>
            </section>
            <section>
                <h3>Bracket - more</h3>
                <pre><code class="scala" embed="ce-tc/bracket-concrete.sc"></code></pre>
            </section>
            <section>
                <h3>Resource data type</h3>
                <pre><code class="scala smaller" embed="ce-tc/resource.scala"></code></pre>
                <pre class="fragment"><code class="scala smaller" embed="ce-tc/resource-example.sc"></code></pre>
            </section>
            <section>
                <h3>Sync typeclass</h3>
                <small>Suspend side effects in F[_]</small>
                <pre><code class="scala" embed="ce-tc/sync.scala"></code></pre>
            </section>
            <section>
                <h3>Sync - example</h3>
                <pre><code class="scala" embed="ce-tc/sync-usage.sc"></code></pre>
            </section>
            <section>
                <h3>LiftIO</h3>
                <small>Convert an IO to F[_]</small>
                <pre><code class="scala" embed="ce-tc/liftio.scala"></code></pre>
            </section>
            <section>
                <h3>Async</h3>
                <small>Execute asynchronous effects</small>
                <pre><code class="scala" embed="ce-tc/async.scala"></code></pre>
            </section>
            <section>
                <h3>Async - example</h3>
                <pre><code class="scala smaller" embed="ce-tc/async-example.sc"></code></pre>
            </section>
        </section>
        <!--CE DTs-->
        <section>
            <section>
                <h3>Cats-effect datatypes</h3>
                <ul>
                    <li>IO</li>
                    <li>SyncIO</li>
                    <li>Fiber</li>
                    <li>Ref</li>
                    <li>Deferred</li>
                    <li>Semaphore</li>
                    <li>Clock</li>
                    <li>ContextShift</li>
                    <li>Timer</li>
                </ul>
            </section>
        </section>
        <section>section 9</section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>
<script src="node_modules/axios/dist/axios.min.js"></script>

<script>
    const Embed = ({fetchFileContents}) => {
        return {
            insertCode: async elem => {
                const path = elem.getAttribute("embed");

                elem.innerHTML = await fetchFileContents(path);
            },
            async init() {
                const self = this;

                const elems = document.querySelectorAll("[embed]");

                await Promise.all([...elems].map(self.insertCode));
                console.log(`Inserted code for ${elems.length} node(s)`);
            }
        };
    };

    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies

    Reveal.initialize({
        dependencies: [
            {src: 'plugin/markdown/marked.js'},
            {src: 'plugin/markdown/markdown.js'},
            {src: 'plugin/notes/notes.js', async: true},
            {
                src: 'plugin/highlight/highlight.js', async: true, callback: function () {
                    hljs.initHighlightingOnLoad();
                }
            }
        ]
    });


    axios.defaults.baseURL = 'embeds/src/main/scala/io/typelevel/';
    Embed({
        fetchFileContents: path => axios.get(path).then(r => r.data)
    }).init();

</script>
</body>
</html>
